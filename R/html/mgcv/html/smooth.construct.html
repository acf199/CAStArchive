<html><head><title>R: Constructor functions for smooth terms in a GAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for smooth.construct {mgcv}"><tr><td>smooth.construct {mgcv}</td><td align="right">R Documentation</td></tr></table>
<h2>Constructor functions for smooth terms in a GAM</h2>


<h3>Description</h3>

<p>
Smooth terms in a GAM formula are turned into smooth specification objects of 
class <code>xx.smooth.spec</code> during processing of the formula. Each of these objects is
converted to a smooth object using an appropriate <code>smooth.construct</code> function. New smooth classes 
can be added by writing a new <code>smooth.construct</code> method function and a corresponding 
<code><a href="Predict.matrix.html">Predict.matrix</a></code> method function (see example code below).
</p>
<p>
In practice, <code>smooth.construct</code> is usually called via the wrapper
function <code><a href="smoothCon.html">smoothCon</a></code>.
</p>


<h3>Usage</h3>

<pre>
smooth.construct(object,data,knots)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
is a smooth specification object, generated by an <code><a href="s.html">s</a></code> or <code><a href="te.html">te</a></code> term in a GAM 
formula. Objects generated by <code>s</code> terms have class <code>xx.smooth.spec</code> where <code>xx</code> is given by the 
<code>bs</code> argument of <code>s</code> (this convention allows the user to add their own smoothers). 
If <code>object</code> is not class <code>tensor.smooth.spec</code> it will have the following elements:
<ul>
<dt>term</dt><dd>The names of the covariates for this smooth, in an array.</dd>
<dt>bs.dim</dt><dd>Argument <code>k</code> of the <code>s</code> term generating the object. This is the dimension of the basis 
used to represent the term (or, arguably, 1 greater than the basis dimension for <code>cc</code> terms).</dd>
<dt>fixed</dt><dd><code>TRUE</code> if the term is to be unpenalized, otherwise <code>FALSE</code>.</dd>
<dt>dim</dt><dd>the number covariates of which this smooth is a function.</dd>
<dt>p.order</dt><dd>the order of the smoothness penalty or 0 for autoselection of this. This is argument 
<code>m</code> of the <code>s</code> term that generated <code>object</code>.</dd>
<dt>by</dt><dd>the name of any <code>by</code> variable to multiply this term as supplied as an argument to <code>s</code>. 
<code>"NA"</code> if there is no such term.</dd>
<dt>full.call</dt><dd>The full version of the <code>s</code> term, with all defaults expanded explicitly.</dd>
<dt>label</dt><dd>A suitable label for use with this term.</dd>
<dt>null.space.dim</dt><dd>The dimension of the null space of the wiggliness penalty.</dd>
</ul>
If <code>object</code> is of class <code>tensor.smooth.spec</code> then it was generated by a <code>te</code> term in the GAM formula, 
and specifies a smooth of several variables with a basis generated as a tensor product of lower dimensional bases. 
In this case the object will be different and will have the following elements:
<ul>
<dt>margin</dt><dd>is a list of smooth specification objects of the type listed above, defining the bases which have 
their tensor product formed in order to construct this term.</dd>
<dt>term</dt><dd>is the array of names of the covariates that are arguments of the smooth.</dd>
<dt>by</dt><dd>is the name of any <code>by</code> variable, or <code>"NA"</code>.</dd>
<dt>fx</dt><dd>is an array, the elements of which indicate whether (<code>TRUE</code>) any of the margins in the 
tensor product should be unpenalized.</dd>
<dt>full.call</dt><dd>The full version of the <code>s</code> term, with all defaults expanded explicitly.</dd>
<dt>label</dt><dd>A suitable label for use with this term.</dd>
<dt>dim</dt><dd>is the number of covariates of which this smooth is a function.</dd>
<dt>null.space.dim</dt><dd>The dimension of the null space of the wiggliness penalty.</dd>
</ul></td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
a data frame in which the covariates and any <code>by</code> variable can be found.</td></tr>
<tr valign="top"><td><code>knots</code></td>
<td>
an optional data frame specifying knot locations for each covariate. If it is null then the knot 
locations are generated automatically.</td></tr>
</table>

<h3>Details</h3>

<p>
The returned objects for the built in smooth classes have the following extra elements.
<code>cr.smooth</code> objects (generated using <code>bs="cr"</code>) have an additional array <code>xp</code> giving the knot locations used to generate the basis.
</p>
<p>
<code>cyclic.smooth</code> objects (generated using <code>bs="cc"</code>) have an array <code>xp</code> of knot locations and a matrix 
<code>BD</code> used to define the basis (BD transforms function values at the knots to second derivatives at the knots).
</p>
<p>
<code>tprs.smooth</code> objects require several items to be stored in order to define the basis. These are:
<ul> 
<dt>shift</dt><dd>A record of the shift applied to each covariate in order to center it around zero and 
avoid any co-linearity problems that might otehrwise occur in the penalty null space basis of the term. </dd>
<dt>Xu</dt><dd>A matrix of the unique covariate combinations for this smooth (the basis is constructed by first stripping 
out duplicate locations).</dd>
<dt>UZ</dt><dd>The matrix mapping the t.p.r.s. parameters back to the parameters of a full thin plate spline.</dd>
<dt>null.space.dimension</dt><dd>The dimension of the space of functions that have zero wiggliness according to the 
wiggliness penalty for this term.</dd>
</ul>

<p>
Again, these extra elements would be found in the elements of the <code>margin</code> list of <code>tensor.smooth</code> 
class object.
</p>
<p>
The classes <code>cs.smooth</code> and <code>ts.smooth</code> are modifications of the
classes <code>cr.smooth</code> and <code>tprs.smooth</code> respsectively: they differ
only in having an extra shrinkage component added to their penalties, so that
automatic model selection can effectively remove such terms from a model altogether.
</p>


<h3>Value</h3>

<p>
The input argument <code>object</code>, assigned a new class to indicate what type of smooth it is and with at least the 
following items added:
</p>
<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
The model matrix from this term.</td></tr>
<tr valign="top"><td><code>C</code></td>
<td>
The matrix defining any constraints on the term - usually a one row matrix giving the column sums of the  
model matrix, which defines the constraint that each term should sum to zero over the covariate values.</td></tr>
<tr valign="top"><td><code>S</code></td>
<td>
A list of positive semi-definite penalty matrices that apply to this term. The list will be empty 
if the term is to be left un-penalized.</td></tr>
<tr valign="top"><td><code>rank</code></td>
<td>
an array giving the ranks of the penalties.</td></tr>
<tr valign="top"><td><code>df</code></td>
<td>
the degrees of freedom associated with this term (at least when unpenalized).</td></tr>
</table>
<p>

<br>
Usually the returned object will also include extra information required to define the basis, and used by 
<code><a href="Predict.matrix.html">Predict.matrix</a></code> methods to make predictions using the basis. See the <code>Details</code> section for the infomation included for the built in smooth classes. 
<br>
<code>tensor.smooth</code> returned objects will additionally have each element of the <code>margin</code> list updated in the same way.</p>

<h3>Author(s)</h3>

<p>
Simon N. Wood <a href="mailto:simon.wood@r-project.org">simon.wood@r-project.org</a>
</p>


<h3>References</h3>

<p>
Wood, S.N. (2000)  Modelling and Smoothing Parameter Estimation
with Multiple  Quadratic Penalties. J.R.Statist.Soc.B 62(2):413-428
</p>
<p>
Wood, S.N. (2003) Thin plate regression splines. J.R.Statist.Soc.B 65(1):95-114
</p>
<p>
Wood, S.N. (in press) Stable and efficient multiple smoothing parameter estimation for
generalized additive models. J. Amer. Statist. Ass.
</p>
<p>
The p-spline code given in the example is based on:
</p>
<p>
Eilers, P.H.C. and B.D. Marx (1996) Flexible Smoothing with B-splines and Penalties. 
Statistical Science, 11(2):89-121
</p>
<p>
<a href="http://www.stats.gla.ac.uk/~simon/">http://www.stats.gla.ac.uk/~simon/</a>
</p>


<h3>See Also</h3>

<p>
<code>get.var</code>, <code><a href="gamm.html">gamm</a></code>, <code><a href="gam.html">gam</a></code>,
<code><a href="Predict.matrix.html">Predict.matrix</a></code>,
<code><a href="smoothCon.html">smoothCon</a></code>, <code><a href="smoothCon.html">PredictMat</a></code>
</p>


<h3>Examples</h3>

<pre># adding "p-spline" classes and methods

smooth.construct.ps.smooth.spec&lt;-function(object,data,knots)
# a p-spline constructor method function
{ require(splines)
  if (length(object$p.order)==1) m&lt;-rep(object$p.order,2) 
  else m&lt;-object$p.order  # m[1] - basis order, m[2] - penalty order
  nk&lt;-object$bs.dim-m[1]  # number of interior knots
  if (nk&lt;=0) stop("basis dimension too small for b-spline order")
  x &lt;- get.var(object$term,data)  # find the data
  xl&lt;-min(x);xu&lt;-max(x);xr&lt;-xu-xl # data limits and range
  xl&lt;-xl-xr*0.001;xu&lt;-xu+xr*0.001;dx&lt;-(xu-xl)/(nk-1) 
  if (!is.null(knots)) k &lt;- get.var(object$term,knots) 
  else k&lt;-NULL
  if (is.null(k)) 
  k&lt;-seq(min(x)-dx*(m[1]+1),max(x)+dx*(m[1]+1),length=nk+2*m[1]+2)   
  if (length(k)!=nk+2*m[1]+2) 
  stop(paste("there should be ",nk+2*m[1]+2," supplied knots"))
  object$X&lt;-spline.des(k,x,m[1]+2,x*0)$design # get model matrix
  if (!object$fixed)       
  { S&lt;-diag(object$bs.dim);if (m[2]) for (i in 1:m[2]) S&lt;-diff(S)
    object$S&lt;-list(t(S)%*%S)  # get penalty
    object$S[[1]] &lt;- (object$S[[1]]+t(object$S[[1]]))/2 # exact symmetry
  }
  object$rank&lt;-object$bs.dim-m[2]  # penalty rank 
  object$null.space.dim &lt;- m[2]  # dimension of unpenalized space  
  object$knots&lt;-k;object$m&lt;-m      # store p-spline specific info.
  object$C&lt;-matrix(colSums(object$X),1,object$bs.dim) #constraint
  object$df&lt;-ncol(object$X)-1      # maximum DoF
  if (object$by!="NA")  # deal with "by" variable 
  { by &lt;- get.var(object$by,data) # find by variable  
    if (is.null(by)) stop("Can't find by variable")
    object$X&lt;-by*object$X # form diag(by)%*%X
  }
  class(object)&lt;-"pspline.smooth"  # Give object a class
  object
}

Predict.matrix.pspline.smooth&lt;-function(object,data)
# prediction method function for the p.spline smooth class
{ require(splines)
  x &lt;- get.var(object$term,data)
  spline.des(object$knots,x,object$m[1]+2,x*0)$design
}

# an example, using the new class....
set.seed(0);n&lt;-400;
x0 &lt;- runif(n, 0, 1);x1 &lt;- runif(n, 0, 1)
x2 &lt;- runif(n, 0, 1);x3 &lt;- runif(n, 0, 1)
f &lt;- 2 * sin(pi * x0)
f &lt;- f + exp(2 * x1) - 3.75887
f &lt;- f+0.2*x2^11*(10*(1-x2))^6+10*(10*x2)^3*(1-x2)^10-1.396
e &lt;- rnorm(n)*2
y &lt;- f + e
b&lt;-gam(y~s(x0,bs="ps",m=2)+s(x1,bs="ps",m=c(1,3))+
         s(x2,bs="ps",m=2)+s(x3,bs="ps",m=2))
plot(b,pages=1)
# another example using tensor products of the new class

test1&lt;-function(x,z,sx=0.3,sz=0.4)
{ (pi**sx*sz)*(1.2*exp(-(x-0.2)^2/sx^2-(z-0.3)^2/sz^2)+
  0.8*exp(-(x-0.7)^2/sx^2-(z-0.8)^2/sz^2))
}
n&lt;-400
x&lt;-runif(n);z&lt;-runif(n);
f &lt;- test1(x,z)
y &lt;- f + rnorm(n)*0.1
b &lt;- gam(y~te(x,z,bs=c("ps","ps"),m=c(2,2)))
vis.gam(b)
</pre>



<hr><div align="center">[Package <em>mgcv</em> version 1.2-3 <a href="00Index.html">Index]</a></div>

</body></html>
