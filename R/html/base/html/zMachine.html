<html><head><title>R: Numerical Characteristics of the Machine</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for .Machine {base}"><tr><td>.Machine {base}</td><td align="right">R Documentation</td></tr></table>
<h2>Numerical Characteristics of the Machine</h2>


<h3>Description</h3>

<p>
<code>.Machine</code> is a variable holding information on the numerical
characteristics of the machine <font face="Courier New,Courier" color="#666666"><b>R</b></font> is running on, such as the largest
double or integer and the machine's precision.
</p>


<h3>Usage</h3>

<pre>
.Machine
</pre>


<h3>Details</h3>

<p>
The algorithm is based on Cody's (1988) subroutine MACHAR.
</p>


<h3>Value</h3>

<p>
A list with components (for simplicity, the prefix &ldquo;double&rdquo; is
omitted in the explanations)
</p>
<table summary="R argblock">
<tr valign="top"><td><code>double.eps</code></td>
<td>
the smallest positive floating-point number
<code>x</code> such that <code>1 + x != 1</code>.  It equals
<code>base^ulp.digits</code> if either <code>base</code> is 2 or <code>rounding</code>
is 0;  otherwise, it is <code>(base^ulp.digits) / 2</code>.</td></tr>
<tr valign="top"><td><code>double.neg.eps</code></td>
<td>
a small positive floating-point number <code>x</code>
such that <code>1 - x != 1</code>.  It equals <code>base^neg.ulp.digits</code>
if <code>base</code> is 2 or <code>round</code> is 0;  otherwise, it is
<code>(base^neg.ulp.digits) / 2</code>.
As <code>neg.ulp.digits</code> is bounded below by <code>-(digits + 3)</code>,
<code>neg.eps</code> may not be the smallest number that can alter 1 by
subtraction.</td></tr>
<tr valign="top"><td><code>double.xmin</code></td>
<td>
the smallest non-vanishing normalized
floating-point power of the radix, i.e., <code>base^min.exp</code>.</td></tr>
<tr valign="top"><td><code>double.xmax</code></td>
<td>
the largest finite floating-point number.
Typically, it is equal to <code>(1 - neg.eps) * base^max.exp</code>, but
on some machines it is only the second, or perhaps third, largest
number, being too small by 1 or 2 units in the last digit of the
significand.</td></tr>
<tr valign="top"><td><code>double.base</code></td>
<td>
the radix for the floating-point representation</td></tr>
<tr valign="top"><td><code>double.digits</code></td>
<td>
the number of base digits in the floating-point
significand</td></tr>
<tr valign="top"><td><code>double.rounding</code></td>
<td>
the rounding action. <br>
0 if floating-point addition chops; <br>
1 if floating-point addition rounds, but not in the IEEE style; <br>
2 if floating-point addition rounds in the IEEE style; <br>
3 if floating-point addition chops, and there is partial underflow; <br>
4 if floating-point addition rounds, but not in the IEEE style, and
there is partial underflow; <br>
5 if floating-point addition rounds in the IEEE style, and there is
partial underflow</td></tr>
<tr valign="top"><td><code>double.guard</code></td>
<td>
the number of guard digits for multiplication
with truncating arithmetic.  It is 1 if floating-point arithmetic
truncates and more than <code>digits</code> base <code>base</code> digits
participate in the post-normalization shift of the floating-point
significand in multiplication, and 0 otherwise.</td></tr>
<tr valign="top"><td><code>double.ulp.digits</code></td>
<td>
the largest negative integer <code>i</code> such
that <code>1 + base^i != 1</code>, except that it is bounded below by
<code>-(digits + 3)</code>.</td></tr>
<tr valign="top"><td><code>double.neg.ulp.digits</code></td>
<td>
the largest negative integer <code>i</code>
such that <code>1 - base^i != 1</code>, except that it is bounded below by
<code>-(digits + 3)</code>.</td></tr>
<tr valign="top"><td><code>double.exponent</code></td>
<td>
the number of bits (decimal places if <code>base</code> is 10) reserved
for the representation of the exponent (including the bias or sign)
of a floating-point number</td></tr>
<tr valign="top"><td><code>double.min.exp</code></td>
<td>
the largest in magnitude negative integer <code>i</code> such that
<code>base ^ i</code> is positive and normalized.</td></tr>
<tr valign="top"><td><code>double.max.exp</code></td>
<td>
the smallest positive power of <code>base</code> that overflows.</td></tr>
<tr valign="top"><td><code>integer.max</code></td>
<td>
the largest integer which can be represented.</td></tr>
<tr valign="top"><td><code>sizeof.long</code></td>
<td>
the number of bytes in a C <code>long</code> type.</td></tr>
<tr valign="top"><td><code>sizeof.longlong</code></td>
<td>
the number of bytes in a C <code>long long</code>
type. Will be zero if there is no such type.</td></tr>
<tr valign="top"><td><code>sizeof.longdouble</code></td>
<td>
the number of bytes in a C <code>long double</code>
type. Will be zero if there is no such type.</td></tr>
<tr valign="top"><td><code>sizeof.pointer</code></td>
<td>
the number of bytes in a C <code>SEXP</code>
type.</td></tr>
</table>

<h3>References</h3>

<p>
Cody, W. J. (1988)
MACHAR: A subroutine to dynamically determine machine parameters.
<EM>Transactions on Mathematical Software</EM>, <B>14</B>, 4, 303&ndash;311.
</p>


<h3>See Also</h3>

<p>
<code><a href="Platform.html">.Platform</a></code> for details of the platform.
</p>


<h3>Examples</h3>

<pre>
.Machine
## or for a neat printout
noquote(unlist(format(.Machine)))
</pre>



<hr><div align="center">[Package <em>base</em> version 2.1.0 <a href="00Index.html">Index]</a></div>

</body></html>
