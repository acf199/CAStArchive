<html><head><title>R: Partial String Matching</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for pmatch {base}"><tr><td>pmatch {base}</td><td align="right">R Documentation</td></tr></table>
<h2>Partial String Matching</h2>


<h3>Description</h3>

<p>
<code>pmatch</code> seeks matches for the elements of its first argument
among those of its second.
</p>


<h3>Usage</h3>

<pre>
pmatch(x, table, nomatch = NA, duplicates.ok = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
the values to be matched.</td></tr>
<tr valign="top"><td><code>table</code></td>
<td>
the values to be matched against.</td></tr>
<tr valign="top"><td><code>nomatch</code></td>
<td>
the value returned at non-matching or multiply
partially matching positions.</td></tr>
<tr valign="top"><td><code>duplicates.ok</code></td>
<td>
should elements be in <code>table</code> be used more
than once?</td></tr>
</table>

<h3>Details</h3>

<p>
The behaviour differs by the value of <code>duplicates.ok</code>. Consider
first the case if this is true.  First exact matches are considered,
and the positions of the first exact matches are recorded. Then unique
partial matches are considered, and if found recorded. (A partial
match occurs if the whole of the element of <code>x</code> matches the
beginning of the element of <code>table</code>.)  Finally,
all remaining elements of <code>x</code> are regarded as unmatched.
In addition, an empty string can match nothing, not even an exact
match to an empty string.  This is the appropriate behaviour for
partial matching of character indices, for example.
</p>
<p>
If <code>duplicates.ok</code> is <code>FALSE</code>, values of <code>table</code> once
matched are excluded from the search for subsequent matches.  This
behaviour is equivalent to the <font face="Courier New,Courier" color="#666666"><b>R</b></font> algorithm for argument
matching, except for the consideration of empty strings (which in
argument matching are matched after exact and partial matching to any
remaining arguments).
</p>
<p>
<code><a href="charmatch.html">charmatch</a></code> is similar to <code>pmatch</code> with
<code>duplicates.ok</code> true, the differences being that it
differentiates between no match and an ambiguous partial match,  it
does match empty strings, and it does not allow multiple exact matches.
</p>


<h3>Value</h3>

<p>
A numeric vector of integers (including <code>NA</code> if <code>nomatch =
    NA</code>) of the same length as <code>x</code>, giving the indices of the
elements in <code>table</code> which matched, or <code>nomatch</code>.</p>

<h3>References</h3>

<p>
Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<EM>The New S Language</EM>.
Wadsworth &amp; Brooks/Cole.
</p>
<p>
Chambers, J. M. (1998)
<EM>Programming with Data. A Guide to the S Language</EM>.
Springer.
</p>


<h3>See Also</h3>

<p>
<code><a href="match.html">match</a></code>, <code><a href="charmatch.html">charmatch</a></code> and
<code><a href="match.arg.html">match.arg</a></code>, <code><a href="match.fun.html">match.fun</a></code>,
<code><a href="match.call.html">match.call</a></code>, for function argument matching etc.,
<code><a href="grep.html">grep</a></code> etc for more general (regexp) matching of strings.
</p>


<h3>Examples</h3>

<pre>
pmatch("", "")                             # returns NA
pmatch("m",   c("mean", "median", "mode")) # returns NA
pmatch("med", c("mean", "median", "mode")) # returns 2

pmatch(c("", "ab", "ab"), c("abc", "ab"), dup=FALSE)
pmatch(c("", "ab", "ab"), c("abc", "ab"), dup=TRUE)
## compare
charmatch(c("", "ab", "ab"), c("abc", "ab"))
</pre>



<hr><div align="center">[Package <em>base</em> version 2.1.0 <a href="00Index.html">Index]</a></div>

</body></html>
